package com.dranawhite.algorithm.sort;

import java.util.Arrays;

/**
 * Jdk自带排序
 * <pre>
 *      优化的归并排序既快速（nlog(n)）又稳定
 *      对于对象的排序，稳定性很重要。比如成绩单，一开始可能是按人员的学号顺序排好了的，现在让我们用成绩排，
 *  那么你应该保证，本来张三在李四前面，即使他们成绩相同，张三不能跑到李四的后面去。
 *      而快速排序是不稳定的，而且最坏情况下的时间复杂度是O(n^2)。
 *      另外，对象数组中保存的只是对象的引用，这样多次移位并不会造成额外的开销，但是，对象数组对比较次数一般
 *  比较敏感，有可能对象的比较比单纯数的比较开销大很多。归并排序在这方面比快速排序做得更好，这也是选择它作为对象
 *  排序的一个重要原因之一。
 *      排序优化：实现中快排和归并都采用递归方式，而在递归的底层，也就是待排序的数组长度小于7时，直接使用冒泡
 *  排序，而不再递归下去。
 *      分析：长度为6的数组冒泡排序总比较次数最多也就1+2+3+4+5+6=21次，最好情况下只有6次比较。而快排或归并涉
 *  及到递归调用等的开销，其时间效率在n较小时劣势就凸显了，因此这里采用了冒泡排序，这也是对快速排序极重要的优化。
 * </pre>
 *
 * @author dranawhite 2017/9/14
 * @version 1.0
 */
public class JdkSort implements Sort {

    @Override
    public void sort(Integer[] arrs) {
        Arrays.sort(arrs);
    }
}
